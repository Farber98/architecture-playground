package tasks

import (
	"encoding/json"
	"fmt"
	"slices"
	"time"

	"github.com/google/uuid"
)

// TaskStatus represents the lifecycle state of a task
type TaskStatus string

const (
	StatusSubmitted TaskStatus = "submitted"
	StatusQueued    TaskStatus = "queued"
	StatusRunning   TaskStatus = "running"
	StatusDone      TaskStatus = "done"
	StatusFailed    TaskStatus = "failed"
)

// String implements the Stringer interface
func (s TaskStatus) String() string {
	return string(s)
}

// IsFinal returns true if this status represents a terminal state
func (s TaskStatus) IsFinal() bool {
	return s == StatusDone || s == StatusFailed
}

// IsActive returns true if the task is in an active processing state
func (s TaskStatus) IsActive() bool {
	return s == StatusRunning
}

// canTransitionTo checks if a transition from current status to target is valid
func (s TaskStatus) canTransitionTo(target TaskStatus) error {
	// Define valid state transitions
	validTransitions := map[TaskStatus][]TaskStatus{
		StatusSubmitted: {StatusRunning, StatusQueued, StatusFailed}, // V1 can start running, V2 can go to queue
		StatusQueued:    {StatusRunning, StatusFailed},               // V2: From queue to processing or failure
		StatusRunning:   {StatusDone, StatusFailed},                  // Can complete or fail during execution
		StatusDone:      {},                                          // Terminal state - no transitions
		StatusFailed:    {},                                          // Terminal state - no transitions
	}

	allowed, exists := validTransitions[s]
	if !exists {
		return fmt.Errorf("unknown current status: %s", s)
	}

	if slices.Contains(allowed, target) {
		return nil // Valid transition
	}

	return fmt.Errorf("invalid transition from %s to %s", s, target)
}

// Task represents a unit of work submitted to the system.
type Task struct {
	// ID is a UUID generated by the server.
	ID string `json:"id"`

	// Type identifies the kind of task (e.g., "print", "sleep").
	// Handlers are resolved dynamically based on this field.
	Type string `json:"type"`

	// Payload holds task-specific parameters in raw JSON.
	// It is decoded only by the handler responsible for the task type.
	Payload json.RawMessage `json:"payload"`

	// Status reflects the current lifecycle state of the task.
	// Set to "submitted" initially, then updated by the runner.
	Status TaskStatus `json:"status"`

	// Result holds the outcome of task execution as a user-readable message.
	// This is populated by the handler once the task has completed.
	Result string `json:"result"`

	// timing information for queueing
	SubmittedAt time.Time  `json:"submitted_at"`
	QueuedAt    *time.Time `json:"queued_at,omitempty"`
	StartedAt   *time.Time `json:"started_at,omitempty"`
	CompletedAt *time.Time `json:"completed_at,omitempty"`
}

// NewTask creates a new task with the submitted status
func NewTask(taskType string, payload json.RawMessage) *Task {
	return &Task{
		ID:          uuid.New().String(),
		Type:        taskType,
		Payload:     payload,
		Status:      StatusSubmitted,
		Result:      "",
		SubmittedAt: time.Now(),
	}
}

// SetStatus updates the task status with validation
func (t *Task) SetStatus(newStatus TaskStatus) error {
	if err := t.Status.canTransitionTo(newStatus); err != nil {
		return fmt.Errorf("task %s: %w", t.ID, err)
	}
	t.Status = newStatus
	return nil
}
